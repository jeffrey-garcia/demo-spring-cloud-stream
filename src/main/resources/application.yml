# Local RabbitMQ binder config
spring:
  cloud:
    stream:
      rabbit:
        bindings:
          output:
            producer:
              # A SpEL expression to determine the routing key to use when publishing messages
              routingKeyExpression: '"test.event.1"'
              # The routing key  to use when publishing messages
              bindingRoutingKey: test.event.1
              # make the channel transactional for each publish, guarantee a message isn't lost
              transacted: true
          input:
            consumer:
              # The routing key with which to bind the queue to the exchange
              bindingRoutingKey: test.event.1
              # Configure the consumer to manually acknowledge message
              # avoid using manual ack since the listener container will do that
              # automatically for you with AUTO ack mode, manual acks is for special
              # use cases such as deferring acks, or early acking.
              # During AUTO ack mode, the default behavior is:
              # - the container will ack the message (and discard it) if the listener exits normally
              # - the container will reject the message (and requeue it) if the listener throws an exception
#              acknowledgeMode: manual
              # The maximum number of consumers
              maxConcurrency: 3
              # dlx/dlq setup
              autoBindDlq: true
              # The backoff time to wait between re-deliveries
              # when the backoff time expired, message from the DLQ are routed back to original queue
              dlqTtl: 15000
              # The dlqDeadLetterExchange property is specified with no value,
              # which means route expired messages to the default exchange DLX
              dlqDeadLetterExchange:
              # When maxAttempt = 1 (internal retry disabled) AND requeueRejected = true
              # any rejected/failed message will be re-queued and retry exhaustively
              # When DLQ is configured, set requeueRejected = false such that any exception thrown
              # can cause the rejected/failed message to be routed to DLQ instead of infinite retry
              requeueRejected: false
      bindings:
        input:
          # Name of the Exchange
          destination: demo-exchange
          contentType: application/json
          binder: local_rabbit
          # Name of the Queue
          # each application instance will have a dedicated RabbitMQ Consumer instance for its groupâ€™s Queue
          group: demo-queue
          consumer:
            # Disable default binder retry
            # if not configured, default binder will assume 3 attempts before it considered the retries are exhausted
            # if set to 1, binder internal retry will be disabled and message are routed to DLQ right-away when any exception
            maxAttempts: 1
            # The number of concurrent consumers to initially start for each listener
            # raise it to scale the consumption of messages coming in from a queue.
            # however, note that any ordering guarantees are lost once multiple
            # consumers are registered.
            # In general, stick with 1 consumer for low-volume queues.
            concurrency: 1
        output:
          # Name of the Exchange
          destination: demo-exchange
          contentType: application/json
          group: demo-queue
          binder: local_rabbit
      binders:
        local_rabbit:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                # connect to RabbitMQ cluster and fail-over at the client-side regardless a HA-proxy
                addresses: localhost:5674,localhost:5672
#                host: localhost
#                port: 5672
                username: guest
                password: guest
                connectionTimeout: 60000
                # Requested heartbeat timeout, in seconds; zero for none.
                requestedHeartbeat: 15000
